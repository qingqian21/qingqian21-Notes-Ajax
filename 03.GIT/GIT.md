# GIT

## 1. 版本控制系统

### 1.1 版本控制系统的分类

- 本地版本控制系统

  单机运行，使维护文件版本的操作工具化

- 集中化的版本控制系统

  联网运行，支持多人协助开发：性能差，用户体验不好

  典型代表： `SVN` 

- 分布式版本控制系统

  联网运行，支持多人协作开发；性能优秀，用户体验良好。

  典型代表： `GIT` 

------

# GIT 起步

## 1. SVN 与 GIT 比较

### 1.1 SVN 的差异比较

-  `SVN` 是基于差异的版本控制，它存储的是一组基本文件和每个文件随时间逐步累积的差异。

### 1.2 GIT 的记录快照

-  `GIT` 快照是在原有文件版本的基础上重新生成一份新的文件，类似于备份。为了效率，若文件没有修改， `GIT` 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。

## 2. GIT 中的三个区域

使用 GIT 管理的项目，拥有三个区域，分别是 工作区，暂存区，`GIT` 仓库。

## 3. GIT 中的三种状态

GIT 管理的项目有三种状态：已修改( `modified` )，已暂存( `staged` )，已提交( `committed` )。

- 已修改( `modified` )

  表示修改了文件，但还没将修改的结果放到暂存区。

- 已暂存( `staged` )

  表示对已修改文件的当前版本做了标记，使之包含在下次提交的列表中。

- 已提交( `committed` )

  表示文件已经安全地保存在本地的 `GIT` 仓库中。

- 注意：
  - 工作区的文件被修改了，但还没有放到暂存区，就是**已修改**状态。
  - 若文件已修改并放入暂存区，就属于**已暂存**状态。
  - 若 `GIT` 仓库中保存着特定版本的文件，就属于**已提交**状态。

------

# GIT 基础

## 1. 配置用户信息

安装 `GIT` 后，要做的第一件事就是设置自己的**用户名**和**邮箱地址**。因为通过 `GIT` 对项目进行版本管理时，`GIT` 需要使用这些基本信息，来记录是谁对项目进行了操作。

```
git config --global user.name "用户名"
git config --global user.email "邮箱地址"
```

注意：如果使用了 `--global` 选项，那么该命令只需要运行一次，即可永久生效。

## 2. GIT 的全局配置文件

通过 `git config --global user.name` 和 `git config --global user.email` 配置的用户名和邮箱地址，会被写入到 `C:/Users/用户名文件夹/.gitconfig` 文件夹中。这个文件是 GIT 的全局配置文件，配置一次即可永久生效。

可以通过记事本打开此文件，查看曾经对 GIT 做了哪些全局性的配置。

## 3. 通过命令形式检查全局配置信息

可以运行终端命令，快速查看 GIT 的全局配置信息

```
// 查看所有的全局配置项
git config --list --global

// 查看指定的全局配置项
git config user.name
git config user.email
```

## 4. 获取帮助信息

可以使用 `git help <verb>` 命令，无需联网即可在浏览器中打开帮助手册

```
// 打开 git config 命令的帮助手册
git help config
```

若不想查看完整的手册，则可以使用 `-h` 选项获取更简明的 `help` 输出

```
// 想要获取 git config 命令的快速参考
git config -h
```

------

# GIT 的基本操作

## 1. 获取 GIT 仓库的两种方式

- **将**尚未进行版本控制的**本地目录转换为 GIT 仓库**
- 从其他服务器**克隆**一个已存在的 GIT 仓库

## 2. 在现有目录中初始化仓库

若自己有一个尚未进行版本控制的项目目录，想要用 GIT 来控制它，需执行如下两个步骤：

1. 在项目目录中，通过鼠标右键打开 `Git Bash` 。
2. 执行 `git init` 命令将当前的目录转化为 GIT 仓库。

注意：`git init` 命令会**创建**一个名为 `.git` 的**隐藏目录**，**这个 `.git` 目录就是当前项目的 GIT 仓库**，里面包含了**初始的必要文件**，这些文件是 GIT 仓库的**必要组成部分**。

## 3. 工作区中文件的 4 中状态

工作区中的每一个文件有可能有 **4 种状态**，这四种状态共分为**两大类**。

![](.\1.png)

GIT 操作的终极结果：让工作区中的文件都处于 **”未修改“** 的状态。

## 4. 检查文件的状态

可以使用 `git status` 命令查看文件处于什么状态。

在状态报告中可以看到 **未跟踪的文件** 出现在 `Untracked files (未跟踪的文件)` 下面，并且**文件名有红色标注**。

未跟踪的文件意味着 GIT 在之前的快照(提交)中没有这些文件；GIT 不会自动将之纳入跟踪范围，除非明确告诉它 ” 我需要使用 GIT 跟踪管理该文件 “。

## 5. 以精简的方式显示文件状态

使用 `git status` 输出的状态报告很详细，但有些繁琐。若希望**以精简的方式显示文件的状态**，可使用如下两条完全等价的命令，其中 **-s 是 --short 的简写形式** 。

```
// 以精简的方式显示文件状态
git status -s
git status --short
```

注意：`未跟踪文件前面会有 红色的 ?? 标记` 。

![](.\2.png) 

## 6. 跟踪新文件

使用命令 `git add` 开始跟踪一个文件。

```
// 跟踪某一个文件
git add 文件名
```

此时在运行 `git status` 命令，会看到 该文件在 `Change to be committed` 这行的下面，说明**已被跟踪**，并**处于暂存状态**。

已精简的方式显示文件的状态：`新添加到暂存区中的文件前面有绿色的 A 标记` 

![](.\3.png) 

## 7. 提交更新

使用 `git add` 后，暂存区中有一个文件 **等待被提交** 到 GIT 仓库中进行保存。可以执行 `git commit` 命令进行提交，其中 **`-m` 选项** 后边是本次的 **提交消息** ，用来 **对提交的内容做进一步的描述** 。

```
// 将暂存区的文件提交给 GIT 仓库
git commit -m "提交信息"
```

提交成功后，会显示如下信息：

![](.\4.png) 

提交成功后，再次检查文件状态，会得到如下提示：

![](.\5.png) 

此时证明工作区中所有的文件都处于 **未修改** 的状态，**没有任何文件需要被提交** 。

![](.\6.png)

## 8. 对已提交的文件进行修改

若文件已被 GIT 跟踪，并且工作区和 GIT 仓库中的文件内容一致。当我们修改了工作区中这个文件的内容后，在次运行 `git status` 和 `git status -s` 命令，就会看到如下内容：

![](.\7.png)

若文件出现在 `Changes not staged for commit` 这行下面，说明 **已跟踪文件的内容发生了变化** ， **但还没有放到暂存区** 。

注意：修改过的，没有放入暂存区的文件前面有 **红色的 `M` 标记** 或 有 **红色 `modified` 标记** 。

## 9. 暂存已修改的文件

若工作区的文件已被修改，若需要暂存这次修改，需要再次运行 `git add` 命令，这个命令是个多功能的命令，主要有如下三个功能：

- 可以用它 **开始跟踪新文件** 
- 把 **已跟踪的** ， **且已修改** 的文件放到暂存区
- 把有冲突的文件标记为已解决状态

![](.\8.png)

注意：修改过的，放入暂存区的文件前面有 **绿色的 `M` 标记** 或 有 **绿色 `modified` 标记** 。

## 10. 提交已暂存的文件

再次运行 `git commit -m "提交消息"` ，即可将暂存区中记录的 快照文件，提交到 GIT 仓库中进行保存。

![](.\9.png)

![](.\10.png)

## 11. 撤销对文件的修改

撤销对文件的修改指的是：把对工作区中对应文件的修改， **还原** 成 GIT 仓库中所保存的版本。

操作的结果：所有的修改会丢失，且无法恢复！ **危险性比较高，请慎重操作！** 

```
// 撤销对文件的修改
git checkout -- 所需还原的文件名
```

![](.\11.png)

 **撤销操作的本质：用 GIT 仓库中保存的文件，覆盖工作区中指定的文件。** 

## 12. 向暂存区中一次性添加多个文件

若需被暂存的文件个数较多，可以使用如下的命令，一次性将所有的新增和修改过的文件加入暂存区

```
// 一次选中多个文件加入到暂存区
git add .
```

 **注意：今后在项目开发中，会经常使用这个命令，将新增和修改过后的文件加入暂存区。** 

## 13. 取消暂存的文件

若需从暂存区中移除对应的文件，可使用如下命令：

```
// 移除暂存区的某个文件
git reset HEAD 要移除的文件名称

// 移除暂存区的所有文件
git reset HEAD .
```

## 14. 跳过使用暂存区域

GIT 标准的工作流程是 **工作区 → 暂存区 → GIT 仓库** ，但有时候这么做略显繁琐，此时可以跳过暂存区，直接将工作区中的修改提交到 GIT 仓库，这时 GIT 工作的流程简化为了 **工作区 → GIT 仓库** 

GIT 提供了一个跳过使用暂存区的方式，只要在提交时，给 `git commit` 加上 `-a` 选项，GIT 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 `git add` 的步骤

```
git commit -a -m "提交信息"
```

## 15. 移除文件

从 GIT 仓库中移除文件的方式有两种：

1. 从 GIT 仓库和工作区中 `同时移除` 对应的文件。
2. 只从 GIT 仓库中移除指定的文件，但保留工作区中对应的文件。

```
// 从 GIT 仓库和工作区中同时移除某文件
git rm -f 文件名

// 只从 GIT 仓库中移除某文件，但保留工作区中的该文件
git rm --cashed 文件名
```

**从 GIT 仓库和工作区同时移除后文件的状态** 

![](.\12.png) 

**只从仓库中移除后的文件状态** 

![](.\13.png) 

使用完该命令后，再次提交时，会执行删除操作。

## 16. 忽略文件

一般我们总会有些文件无需纳入 GIT 的管理，也不希望它们总出现在未跟踪文件列表。在这种情况下，我们可以创建一个名为 `.gitignore` 的配置文件，列出要忽略的文件的匹配模式。

文件 `.gitignore` 的格式规范如下：

1. 以 `# 开头` 的时注释
2. 以 `/ 结尾` 的是目录
3. 以 `/ 开头` 防止递归
4. 以 `! 开头` 表示取反
5. 可以使用 `glob` 模式进行文件和文件夹的匹配( `glob` 指简化了的正则表达式)

## 17. glob 模式

所谓的 `glob` 模式是指简化了的正则表达式：

1.  `星号 *` 匹配 **零个或多个任意字符** 
2.  `[abc]` 匹配 **任何一个列在方括号中的字符** (此案例匹配一个 a 或匹配一个 b 或匹配一个 c)
3.  `问好 ?` 只匹配 **一个任意字符** 
4. `在方括号中使用短划线分隔两个字符`，表示所有在这两个字符范围内的都可以匹配(比如 `[0-9]` 表示匹配 0 到 9 的数字)
5. 两个星号 `**` 表示匹配任意中间目录(比如 `a/**/z` 可以匹配 `a/z` 、`a/b/z` 或 `a/b/c/z` 等)

## 18. `.gitignore` 文件的例子

```
# 忽略所有的 .a 文件，#表示注释
*.a

# 但跟踪所有的 lib.a ，即使你在前面忽略了 .a 文件
!lib.a

# 只忽略当前目录下的 TOOD 文件，而不忽略 subdir/TOOD
/TOOD

# 忽略任何目录下名为 build 的文件夹
build/

# 忽略 doc/notes.txt ，但不忽略 doc/server/arch.txt
doc/*.txt

# 忽略 doc/ 目录及器所有子目录下的 .pdf 文件
doc/**/*.pdf
```

## 19. 查看提交历史

若希望回顾项目的提交历史，可以使用 `git log` 这个简单有效的命令。

```
// 按时间先后顺序列出所有的提交历史，最近的提交排在最上面
git log

// 只展示最新的两条提交历史，数字可按需填写
git log -2

// 在一行上展示最近两条提交历史的信息
git log -2 --pretty=oneline

// 在一行上展示最近两条提交历史的信息，并自定义输出的格式
// %h 提交的简写哈希值   %an 作者名字   %ar 作者修订日期，按多久以前的方式显示   %s 提交说明
git log -2 --pretty=format:"%h  |  %an  |  %ar  |  %s"
```

## 20. 回退到指定的版本

```
// 在一行上展示所有的提交历史
git log --pretty=oneline

// 使用 git reset --hard 命令，根据指定的提交 ID 回退到指定版本
git reset --hard <CommitID>

// 在回退到的旧版本中使用 git reflog --pretty=oneline 命令，查看所有命令操作的历史
git reflog --pretty=oneline

// 再根据最新的提交 ID，跳转到最新的版本
git reset --hard <CommitID>
```

## 21. 小结

1. 初始化 GIT 仓库

   `git init` 

2. 查看文件状态的命令

   `git status` 或 `git status -s` 

3. 一次性将文件加入暂存区的命令

   `git add .` 

4. 将暂存区的文件提交到 GIT 仓库的命令

   `git commit -m "提交消息"` 

------

# Github

## 1. 开源协议

1. BSD
2. Apache Licence 2.0
3. **GPL** 
   - 具有传染性的一种开源协议，不允许修改后和衍生的代码作为闭源的商业软件开发和销售，且使用 GPL 协议的文件开发的文件也只能使用 GPL 协议
   - 项目：Linux
4. LGPL
5. **MIT** 
   - 目前限制最少的协议。唯一条件：在修改后的代码或发行包中，必须包含原作者的许可信息。
   - 项目：jQuery 、 Node.js

## 2. 开源项目托管平台

专门用于免费开放项目源代码的网站，叫做开源项目托管平台。目前世界上比较出名的开源项目托管平台有三个：

- Github
- Gitlab(对代码私有性支持较好，因此企业用户较多)
- Gitee

注意：以上三个开源项目托管平台，只能托管以 GIT 管理类的项目源代码，故，他们都以GIT 开头

## 3. Github 使用

### 3.1 远程仓库的两种访问方式

Githu 上的远程仓库，有两种访问方式，分别是 `HTTPS` 和 `SSH`。它们的区别:

`HTTPS` ：零配置；但每次访问仓库时，需要重复输入 Github 的账号和密码才能访问成功。

`SSH` ：需要进行额外的配置；但是配置成功后，每次访问仓库时，不需要重复输入 Github 的账号和密码。

**实际开发，常用 `SSH` 的方式访问远程仓库。** 

#### 3.1.1 基于 HTTPS 将本地仓库上传到 Github

![](.\14.png)

当后续本地代码更新后，更新仓库代码是，只需要使用 `git push` 再次提交即可。

#### 3.1.2 基于 SSH 将本地仓库上传到 Github

1. SSH key

   SSH key的作用：实现本地仓库与 Github 之间的**免登录的加密数据传输** 。

   SSH key的好处：免登录身份认证、数据加密传输。

   SSH key由两部分组成，分别是：

   - id_rsa(私钥文件，存放于客户端的电脑中即可)
   - id_rsa.pub(公钥文件，需要配置到 Github 中)

2. 生成 SSH key

   - 打开 Git Bash

   - 执行以下命令

     ` ssh-keygen -t rsa -b 4096 -C "注册 Github 时填写的邮箱" ` 

   - 连续敲击三次回车，即可在：`C:\Users\用户名文件夹\.ssh` 目录中生成 `id_rsa` 和 `id_rsa.pub` 两个文件

3. 配置 SSH key

   - 使用记事本打开 `id_rsa.pub` 文件，复制里边的文本内容
   - 在浏览器中登录 Github ，`点击头像 → Settings → SSH and GPG Keys → New SSH Key` 
   - 将 `id_rsa.pub` 文件中的内容，`粘贴到 Key 对应的文本框中` 
   - 在 Title 文本框中任意填写一个名称，来标识这个 Key 从何而来

4. 检测 GIthub 的 SSH key 是否配置成功

   打开 Git Bash ，输入 `ssh -T git@github.com` 并执行，会得到以下提示消息：

   ![](.\15.png) 

   输入 `yes` 后，若能看到类似于下面的提示消息，证明 SSH Key 配置成功

   ![](.\16.png) 

5.  基于 SSH 将本地仓库上传到 Github

   ![](.\17.png)

### 3.2 将远程仓库克隆到本地

打开 `Git bush` ，输入以下命令：

```
git clone 远程仓库的地址
```

------

# GIT 分支

## 1. master 主分支

在初始化本地 GIT 仓库的时候，GIT 默认已经帮我们创建了一个名字叫做 `master` 的分支。通常我们把这个 master 分支叫做**主分支** 。

![](.\18.png)

实际工作中：master 主分支的作用是：**用来保存和记录整个项目已完成的功能代码** 。

## 2. 功能分支

**功能分支** 指的是**专门用来开发新功能的分支** ，它是临时从 master 主分支上分叉出来的，当新功能开发且测试完毕后，最终需要合并到 master 主分支上。

![](.\19.png)

## 3. 查看分支列表

可执行如下命令查看当前 GIT 仓库中所有的分支列表

```
git branch
```

运行结果如下

![](.\20.png) 

**注意：分支名字前面的 `*` 表示当前所处的分支。** GIT 默认处于主分支中。

## 4. 创建新分支

使用如下命令，可以 **基于当前分支，创建一个新的分支** ，此时，新分支中的代码和当前分支完全一样。

```
git branch 新分支名称
```

![](.\21.png)

**注意：执行完创建分支的命令后，用户所处的还是当前的分支。** 

## 5. 切换分支

使用如下命令，可以 **切换到指定的分支上** 进行开发：

```
git checkout 分支名称
```

![](.\22.png)

## 6. 分支的快速创建和切换

使用如下命令，可以 **创建指定名称的新分支** ，并 **立即切换到新分支** 上。

创建分支时，默认都是从 **主分支开始创建新分支** 

```
// -b 表示创建一个新分支
// checkout 表示切换到刚才新建的分支上
git checkout -b 分支名称
```

注意： **`git checkout -b 分支名称` 是 `git checkout 分支名称` 和 `git branch 新分支名称` 两条命令的简写形式，实际开发用该命令较多。** 

![](.\23.png)

## 7. 合并分支

功能分支的代码开发测试完毕后，可使用如下命令，将完成后的代码合并到 master 主分支上。

```
// 切换到 master 分支
git checkout master

// 在 master 主分支上运行 git merge 命令，将 login 分支的代码合并到 master 分支。
git merge login
```

**切换会主分支时，本地文件会恢复到主分支的状态，只有当分支合并后，才会添加新分支的功能。即分支上所有操作主分支上看不到。** 

![](.\24.png)

注意：假设要把 **C 分支的代码合并到 A 分支** 上，则必须 **先切换到 A 分支上，在运行 git merge 命令** ，来合并 C 分支。

## 8. 删除分支

当功能分支的代码合并到 master 主分支上以后，就可以使用如下命令，删除对应的功能分支：

```
git branch -d 分支名称
```

**注意：删除某分支时，不能处于该分支上。** 

## 9. 遇到冲突时的分支合并

若 **在两个不同的分支中** ，对 **同一个文件** 进行了 **不同的修改** ，GIT 就没法干净的合并它们。此时，我们需要  **打开这些包含冲突的文件然后手动解决冲突** 。

```
// 假设：在把 reg 分支合并到 master 分支期间，代码发生了冲突
git checkout master
git merge reg

// 打开包含冲突的文件，手动解决冲突之后，在执行如下命令
git add 提交文件名
git commit -m "提交消息"
```

------

# 远程分支操作

## 1. 将本地分支推送到远程仓库

若是 **第一次** 将本地分支推送到远程仓库，需要运行如下命令：

```
// -u 表示把本地分支和远程分支进行关联，只有在第一次推送的时候需要带 -u 参数
git push -u 远程仓库的别名(默认origin) 本地分支名称:远程分支别名

// 实际案例：
git push -u orgin payment:pay

// 若希望远程分支的名称和本地分支名称保持一致，可以对命令进行简化：
git push -u orgin payment
```

注意：第一次推送分支需要带 `-u` 参数，此后可以直接使用 `git push` 推送代码到远程分支。

**`git remote -v` 可以查看远程仓库的别名** 

## 2. 查看远程仓库中所有的分支列表

通过如下命令，可查看远程仓库中，所有的分支列表信息：

```
git remote show 远程仓库名称
```

